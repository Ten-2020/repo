<!--
 * @Author: 高腾
 * @Description: 
 * @Date: 2020-01-14 17:21:35
 -->
这个文件夹下面的文件 都是在跟着B站->vue源码分析 这个视频 一起学习而来的代码
主要是为了探讨 vue 源码以及动作过程


vue 会先拷贝一个虚拟的DOM,再把数据给到虚拟的DOM,再把虚拟的DOM转换成真正的DOM --- 这是vue的原理
# 虚拟 DOM

目标:
    1.怎么将真正的 DOM 转换成为虚拟的 DOM
    2.怎么将虚拟的 DOM 转换成为真正的 DOM
  思路与深拷贝类似 
  无非就是深度遍历DOM,把节点转换成虚拟的DOM或者把节点转换成真正的DOM



  函数式编程:就是一种"编程范式"（programming paradigm），也就是如何编写程序的方法论。
    1.函数柯里化: 一个函数原本有多个参数,先传入一个参数,生成一个新函数,由新函数接收剩下的参数来运行从而得到结果.
       优点:代码复用，减少维护成本;尽可能的函数化，便于阅读; 
       就是一种规范而已.
    2.偏函数: 一个函数原本有多个参数,先传入部分参数,生成...(跟上面一样了)
    3.高阶函数: 一个函数参数是一个函数，该函数对参数这个函数进行加工，得到一个函数，这个加工用的函数就是高阶函数．
  
  为什么使用柯里化? 为了提升性能,使用柯里化可以缓存一部分能力.

  使用两个案例来说明:1.判断元素 2.虚拟DOM的render方法
  1.判断元素: Vue 本质是使用 HTML 的字符串作为模板的,将字符串的模板转换为 AST,再转换为虚拟 DOM
  - 模板 -> AST(抽象语法树) 
  - AST -> vNode
  - vNode -> DOM
  哪一个阶段最消耗性能? 第一个,因为要对字符串进行解析.

  例子: let s = '1 + 2 * (3 + 4)'  写一个程序,解析这个表达式,得到结果(一般化).
  我们一般会将这个表达式为"波兰式" 表达式,然后用栈结构来运算.这就是一个算法.
------------------------------------------------------------------------
  在 Vue 中每一个标签可以是真正的 HTML 标签,也可以自定义组件,如何区分呢?
  在 Vue 源码中其实将所有可以用的 HTML 标签已经存起来了.在文件:06-柯里化.html中有解答.

  2. 虚拟 DOM 的 render 方法
  思考: vue 项目 模板 转换为 抽象语法树 需要执行几次? 
  - 页面一开始加载需要渲染
  - 每一个属性(响应式)数据在发生变化的时候 要渲染
  - watch,computed 等等
  
  在文件:03-vue-deepProps.html 中的 render 方法,也就是渲染方法,数据一旦改变,就会调用一次compiler方法,性能就会很差.
  这也是很常见的问题!!!
  render 的作用是将 虚拟 DOM 转换为 真正的 DOM 加到页面中.

  - 虚拟 DOM 可以降级理解为 AST // 就让虚拟DOM先等于AST
  - 一个项目运行的时候 模板 是不会变的,就表示 AST 是不会变的
  我们可以将代码进行优化,将 虚拟DOM 缓存起来,生成一个函数,函数只需要传入数据 就可以得到 真正的DOM --- 这应该就是柯里化的思想吧!
  
 

  # 响应式原理

- 我们在使用 Vue 时候, 赋值属性获得属性都是直接使用的 Vue 实例
- 我们在设计属性值的时候, 页面的数据更新

<!-- ```js -->

对于对象可以使用 递归来响应式化, 但是数组我们也需要处理  --- 就是在数组 push 之后,新添加的元素没有响应式化.

- push
- pop
- shift
- unshift
- reverse
- sort
- splice

要做什么事情呢?

1. 在改变数组的数据的时候, 要发出通知
   - Vue 2 中的缺陷, 数组发生变化, 设置 length 没法通知 ( Vue 3 中使用 Proxy 语法 ES6 的语法解决了这个问题 )
2. 加入的元素应该变成响应式的

技巧: 如果一个函数已经定义了, 但是我们需要扩展其功能, 我们一般的处理办法:

1. 使用一个临时的函数名存储函数
2. 重新定义原来的函数
3. 定义扩展的功能
4. 调用临时的那个函数


扩展数组的 push 和 pop 怎么处理呢???

- 直接修改 prototype **不行**
- 修改要进行响应式化的数组的原型 ( __proto__ )

已经将对象改成响应式的了. 但是如果直接给对象赋值, 赋值另一个对象, 那么就不是响应式的了, 怎么办? ( 作业 )

// 继承关系: arr -> Array.prototype -> Object.prototype -> ...
// 继承关系: arr -> 改写的方法 -> Array.prototype -> Object.prototype -> ...
<!-- ``` -->

# 发布订阅模式

任务:

- 作业
- 代理方法 ( app.name, app._data.name )
- 事件模型 ( node: event 模块 )
- vue 中 Observer 与 Watcher 和 Dep

代理方法, 就是要将 app._data 中的成员 给 映射到 app 上 

由于需要在更新数据的时候, 更新页面的内容
所以 app._data 访问的成员 与 app 访问的成员应该时同一个成员

由于 app._data 已经是响应式的对象了, 所以只需要让 app 访问的成员去访问 app._data 的对应成员就可以了.

例如:

```js
app.name 转换为 app._data.name
app.xxx 转换为 app._data.xxx
```

引入了一个函数 proxy( target, src, prop ), 将 target 的操作 映射到 src.prop 上
这里是因为当时没有 `Proxy` 语法 ( ES6 )

我们之前处理的 rectify 方法已经不行了, 我们需要一个新的方法来处理

提供一个 Observer 的方法, 在方法中对 属性进行处理
可以将这个方法封装发到 initData 方法中



## 解释 proxy

```js
app._data.name
// vue 设计, 不希望访问 _ 开头的数据
// vue 中有一个潜规则:
//  - _ 开头的数据是私有数据
//  - $ 开头的是只读数据
app.name
// 将 对 _data.xxx 的访问 交给了 实例

// 重点: 访问 app 的 xxx 就是在访问 app._data.xxx
```

假设:

```js
var  o1 = { name: '张三' };
// 要有一个对象 o2, 在访问 o2.name 的时候想要访问的是 o1.name
Object.defineProperty( o2, 'name', {
  get() {
    return o1.name
  }
} );
```

访问 app 的 xxx 就是在访问 app._data.xxx

```js
Object.defineProperty( app, 'name', {
  get() {
    return app._data.name
  },
  set( newVal ) {
    app._data.name = newVal;
  }
} )
```

将属性的操作转换为 参数

```js
function proxy( app, key ) {
  Object.defineProperty( app, key, {
    get() {
      return app._data[ key ]
    },
    set( newVal ) {
      app._data[ key ] = newVal;
    }
  } )
}
```

问题: 

在 vue 中不仅仅是只有 data 属性, properties 等等 都会挂载到 Vue 实例上

```js
function proxy( app, prop, key ) {
  Object.defineProperty( app, key, {
    get() {
      return app[ prop ][ key ]
    },
    set( newVal ) {
      app[ prop ][ key ] = newVal;
    }
  } )
};

// 如果将 _data 的成员映射到 实例上
proxy( 实例, '_data', 属性名 )
// 如果要 _properties 的成员映射到 实例上
proxy( 实例, '_properties', 属性名 )
```

# 发布订阅模式

目标: 解耦, 让各个模块之间没有紧密的联系

现在的处理办法是 属性在更新的 时候 调用 mountComponent 方法. 

问题: mountComponent 更新的是什么??? (现在) 全部的页面 -> 当前虚拟 DOM 对应的页面 DOM

在 Vue 中, 整个的更新是按照组件为单位进行 **判断**, 已节点为单位进行更新.

- 如果代码中没有自定义组件, 那么在比较算法的时候, 我们会将全部的模板 对应的 虚拟 DOM 进行比较.
- 如果代码中含有自定义组件, 那么在比较算法的时候, 就会判断更新的是哪一些组件中的属性, 只会判断更新数据的组件, 其他组件不会更新.

复杂的页面是有很多组件构成. 每一个属性要更新的都要调用 更新的方法?

**目标, 如果修改了什么属性, 就尽可能只更新这些属性对应的页面 DOM**

这样就一定不能将更新的代码写死.

例子: 预售可能一个东西没有现货, 告诉老板, 如果东西到了 就告诉我. 

老板就是发布者
订阅什么东西作为中间媒介
我就是订阅者

使用代码的结构来描述:

1. 老板提供一个 账簿( 数组 )
2. 我可以根据需求订阅我的商品( 老板要记录下 谁 定了什么东西, 在数组中存储 某些东西 )
3. 等待, 可以做其他的事情
4. 当货品来到的时候, 老板就查看 账簿, 挨个的打电话 ( 遍历数组, 取出数组的元素来使用 )

实际上就是事件模型

1. 有一个 event 对象
2. on, off, emit 方法

实现事件模型, 思考怎么用?

1. event 是一个全局对象
2. event.on( '事件名', 处理函数 ), 订阅事件
   1. 事件可以连续订阅
   2. 可以移除: event.off()
      1. 移除所有
      2. 移除某一个类型的事件
      3. 移除某一个类型的某一个处理函数
3. 写别的代码
4. event.emit( '事件名', 参数 ), 先前注册的事件处理函数就会依次调用
<!-- 
这里如果定义点击事件如下,是无法移除这个点击事件的,因为绑定是后面的方法,而如果是匿名的,就无法找到它的地址,就无法移除.
如果想移除就先定义这个函数,再引用,这样绑定就给移除.
event.on("click",function(){
      let i = 2
      console.info(`第$(i)次绑定click方法`)
    })
    
     
-->
原因:

1. 描述发布订阅模式
2. 后面会使用到事件


发布订阅模式 ( 形式不局限于函数, 形式可以是对象等 ) :

1. 中间的**全局的容器**, 用来**存储**可以被触发的东西( 函数, 对象 )
2. 需要一个方法, 可以往容器中**传入**东西 ( 函数, 对象 )
3. 需要一个方法, 可以将容器中的东西取出来**使用**( 函数调用, 对象的方法调用 )

Vue 模型

页面中的变更 ( diff ) 是一组件为单位

- 如果页面中只有一个组件 ( Vue 实例 ), 不会有性能损失
- 但是如果页面中有多个组件 ( 多 watcher 的一种情况 ), 第一次会有 多个组件的 watcher 存入到 全局watcher 中.
  - 如果修改了局部的数据( 例如其中一个组件的数据 )
  - 表示只会对该组件进行 diff 算法, 也就是说只会重新生成该组件的 抽象语法树
  - 只会访问该组件的 watcher
  - 也就表示再次往全局存储的只有该组件的 watcher
  - 页面更新的时候也就只需要更新一部分
