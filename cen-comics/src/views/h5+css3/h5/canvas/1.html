<!--
 * @Author: 高腾
 * @Description: 
 * @Date: 2020-07-24 10:17:35
-->
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script type="text/javascript">
    function draw() {
      let canvas = document.querySelector('#turorial')
      if (canvas.getContext) { // 支持
        let ctx = canvas.getContext('2d')
        // 矩形(通过绘制原点以及长宽来实现)
        // ctx.fillStyle = "rgb(200,0,0)"
        // ctx.fillRect(10, 10, 55, 50) //clearRect|strokeRect
        // ctx.fillStyle = "rgba(0,0,200,0.5)"
        // ctx.fillRect(30, 30, 55, 190)
        // 三角形(通过绘制所有的点来实现)
        // ctx.beginPath()
        // ctx.moveTo(75,50)
        // ctx.lineTo(100,75)
        // ctx.lineTo(100,25)
        // ctx.lineTo(75,50) //closePath()这个也能实现闭合
        // ctx.stroke() // 如果已经是闭合的就使用stroke()
        // 用fill()不仅会来闭合所有的点,还会使闭合线之内的空白都填充了
        // 圆形(画个脸)
        // ctx.beginPath()
        // ctx.arc(75, 75, 50, 0, Math.PI * 2, true) // 原点坐标,半径,角度,逆时针
        // ctx.moveTo(110, 75) // 这些如果去掉,就会出现上下两个图形的结束与开始节点的连线
        // ctx.arc(75, 75, 35, 0, Math.PI, false)
        // ctx.moveTo(65, 65)
        // ctx.arc(60, 65, 5, 0, Math.PI * 2, true)
        // ctx.moveTo(95, 65)
        // ctx.arc(90, 65, 5, 0, Math.PI * 2, true)
        // ctx.stroke()
        // 二次贝塞尔曲线
        // ctx.beginPath()
        // ctx.moveTo(75, 25)
        // ctx.quadraticCurveTo(25,25,25,62.5)
        // ctx.stroke()
        // 颜色渐变(画很多个漂亮的圆形)
        // for (let i = 0; i < 6; i++) {
        //   for (let j = 0; j < 6; j++) {
        //     // ctx.strokeStyle = 'rgb(0,' + Math.floor(255 - 42.5 * i) + ',' + Math.floor(255 - 42.5 * i) + ')'
        //     ctx.strokeStyle = 'rgb(0,' + Math.floor(150 - 30 * i) + ',' + Math.floor(150 - 30 * i) + ')'
        //     ctx.beginPath()
        //     ctx.arc(15 + 30 *  j, 15 + 30 * i, 11, 0, Math.PI * 2, true)
        //     ctx.stroke()
        //   }
        // }
        // 渐变 Gradients
        // let lingrad = ctx.createLinearGradient(0, 0, 0, 150);
        // lingrad.addColorStop(0, '#00ABEB');
        // lingrad.addColorStop(0.5, '#fff');
        // lingrad.addColorStop(0.5, '#26C000');
        // lingrad.addColorStop(1, '#fff');

        // let lingrad2 = ctx.createLinearGradient(0, 50, 0, 95)
        // lingrad2.addColorStop(0.5, '#000');
        // lingrad2.addColorStop(1, 'rgba(0,0,0,0)');

        // ctx.fillStyle = lingrad;
        // ctx.strokeStyle = lingrad2;

        // ctx.fillRect(10, 10, 130, 130);
        // ctx.strokeRect(50, 50, 50, 50);
        // 填充(fill)
        // ctx.beginPath()
        // ctx.arc(50, 50, 30, 0, Math.PI * 2, true)
        // ctx.arc(50, 50, 15, 0, Math.PI * 2, true)
        // ctx.fill("evenodd") // 只填充两个圆之间的部分
        // 移动 Translating
        // for (let i = 0; i < 3; i++) {
        //   for (let j = 0; j < 3; j++) {
        //     ctx.save()
        //     ctx.fillStyle = 'rgb(0,' + Math.floor(150 - 50 * i) + ',' + Math.floor(150 - 50 * i) + ')'
        //     ctx.translate(10 + j * 50, 10 + i * 50)
        //     ctx.fillRect(0, 0, 15, 15)
        //     ctx.restore()
        //   }
        // }
        // 旋转 Rotating
        // ctx.translate(75, 75)
        // for (var i = 1; i < 2; i++) { // Loop through rings (from inside to out)
        //   ctx.save()
        //   ctx.fillStyle = 'rgb(' + (51 * i) + ',' + (255 - 51 * i) + ',255)'

        //   for (var j = 0; j < i * 6; j++) { // draw individual dots
        //     ctx.rotate(Math.PI * 2 / (i * 6))
        //     ctx.beginPath()
        //     ctx.arc(0, i * 25, 5, 0, Math.PI * 2, true);
        //     ctx.fill()
        //   }
        //   ctx.restore()
        // }
        // 下面是自己实践写的一个圈的圆
        ctx.translate(75, 75)// 给一个原点(现在75,75是原点)
        // ctx.save()
        for (let i = 0; i < 5; i++) {
          ctx.rotate(Math.PI * 2 / (6))
          ctx.beginPath() // 就像重置坐标系一样
          ctx.arc(0,12.5,5,0,Math.PI*2,true) // 旋转了角度之后,这个坐标就是旋转了角度之后的了
          // 如:之前坐标系是y轴是正向南北的,现在旋转角度之后就,就发生了偏移,整个坐标系发生了偏移
          ctx.fill()
        }
        ctx.restore()
      } else {

      }
    }
  </script>
  <style type="text/css">
    canvas {
      border: 1px solid black;
    }
  </style>
</head>

<body onload="draw()">
  <canvas id="turorial" width="150" height="150"></canvas>
</body>

</html>